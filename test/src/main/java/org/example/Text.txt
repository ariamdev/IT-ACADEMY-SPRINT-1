1. Introducción a las Excepciones

---

¿Qué es una excepción?
En términos simples, una excepción es un evento anómalo que ocurre durante la ejecución de un programa que interrumpe el flujo normal de instrucciones. En Java, las excepciones son objetos que representan condiciones inusuales, como errores de entrada/salida, errores de red, conversión incorrecta de datos, y más. Cuando ocurre una excepción, el programa genera (o lanza) un objeto de excepción.

¿Por qué es importante manejar excepciones?
Manejar excepciones es crucial para que el programa sea más robusto y confiable. Si las excepciones no se manejan adecuadamente, pueden hacer que el programa falle y termine abruptamente, mostrando mensajes de error confusos para el usuario. Un manejo adecuado de excepciones asegura que el programa pueda:
- Identificar y responder a errores de forma controlada.
- Continuar su ejecución o finalizar de manera ordenada.
- Proporcionar mensajes de error claros y útiles al usuario o al desarrollador.

---

2. Jerarquía de Excepciones en Java

---

#### **La clase `Throwable`**
En Java, todas las excepciones y errores son subclases de la clase `Throwable`. Esta clase tiene dos subclases principales:
1. **`Exception`**: Representa condiciones que un programa puede manejar.
2. **`Error`**: Representa problemas graves que generalmente no se pueden o no deben manejar (como fallos en la memoria o errores en la JVM).

#### **Diferencias entre `Exception` y `Error`**
- **`Exception`**: Son condiciones que un programa puede prever y manejar. Ejemplos: `IOException`, `SQLException`.
- **`Error`**: Son problemas que surgen en el entorno de ejecución o la JVM y, por lo general, no deben ser manejados por los programas de usuario. Ejemplos: `OutOfMemoryError`, `StackOverflowError`.

#### **Checked vs Unchecked Exceptions**
Las excepciones en Java se dividen en dos categorías:
1. **Checked Exceptions (Excepciones verificadas)**: Son excepciones que el compilador fuerza a manejar. Se deben declarar usando `throws` o manejar con un bloque `try-catch`. Ejemplo: `IOException`, `SQLException`.

   ```java
   public void leerArchivo() throws IOException {
       FileReader file = new FileReader("archivo.txt");
   }
   ```

2. **Unchecked Exceptions (Excepciones no verificadas)**: Son subclases de `RuntimeException`. El compilador no obliga a manejarlas explícitamente, aunque aún pueden causar errores en tiempo de ejecución. Ejemplo: `NullPointerException`, `ArrayIndexOutOfBoundsException`.

   ```java
   String texto = null;
   System.out.println(texto.length());  // Lanza un NullPointerException
   ```

---

### **3. Manejo de Excepciones**

---

#### **Uso de `try`, `catch`, `finally`**

El bloque `try` se utiliza para rodear el código que puede lanzar una excepción. Si ocurre una excepción, el control pasa al bloque `catch`, donde se puede manejar la excepción. El bloque `finally`, si está presente, se ejecuta siempre, independientemente de si se lanzó una excepción o no.

```java
try {
    // Código que puede lanzar una excepción
    int resultado = 10 / 0;
} catch (ArithmeticException e) {
    // Manejo de la excepción
    System.out.println("Error: División por cero");
} finally {
    // Bloque opcional que siempre se ejecuta
    System.out.println("Este bloque siempre se ejecuta");
}
```

#### **Flujo de control con excepciones**
Cuando ocurre una excepción dentro de un bloque `try`, el flujo del programa salta directamente al bloque `catch` correspondiente. Si no hay excepciones, el bloque `catch` se omite.

#### **Propagación de excepciones**
Si una excepción no se maneja en el método donde ocurre, se propaga hacia arriba en la pila de llamadas. Esto significa que la excepción puede ser capturada en un método superior en la jerarquía de llamadas.

---

### **4. Tipos Comunes de Excepciones**

---

1. **`NullPointerException`**: Ocurre cuando se intenta invocar un método o acceder a un campo de un objeto que es `null`.

   ```java
   String str = null;
   System.out.println(str.length());  // Lanza NullPointerException
   ```

2. **`ArrayIndexOutOfBoundsException`**: Se lanza cuando se intenta acceder a una posición inválida de un array.

   ```java
   int[] array = new int[5];
   System.out.println(array[10]);  // Lanza ArrayIndexOutOfBoundsException
   ```

3. **`NumberFormatException`**: Se lanza cuando se intenta convertir una cadena en un número en un formato incorrecto.

   ```java
   String numero = "abc";
   int num = Integer.parseInt(numero);  // Lanza NumberFormatException
   ```

4. **`IOException`**: Esta es una excepción verificada que se lanza cuando ocurre un error en operaciones de entrada/salida.

   ```java
   BufferedReader br = new BufferedReader(new FileReader("archivo.txt"));
   // Lanza IOException si el archivo no existe
   ```

5. **`ArithmeticException`**: Se lanza cuando se realiza una operación aritmética inválida, como una división por cero.

   ```java
   int resultado = 10 / 0;  // Lanza ArithmeticException
   ```

6. **`ClassNotFoundException`**: Se lanza cuando se intenta cargar una clase que no se puede encontrar en el classpath.

   ```java
   Class.forName("MiClaseInexistente");  // Lanza ClassNotFoundException
   ```

---

### **5. Crear Excepciones Personalizadas**

---

#### **¿Por qué crear excepciones personalizadas?**
Las excepciones personalizadas permiten representar errores específicos del dominio o lógica de negocio. Proporcionan una forma clara de indicar qué salió mal en un contexto particular.

#### **Cómo crear una excepción personalizada**
Se puede crear una clase que extienda `Exception` o `RuntimeException` dependiendo de si quieres que sea verificada o no verificada.

```java
public class MiExcepcion extends Exception {
    public MiExcepcion(String mensaje) {
        super(mensaje);
    }
}
```

El uso de esta excepción podría ser el siguiente:

```java
if (edad < 0) {
    throw new MiExcepcion("La edad no puede ser negativa");
}
```

---

### **6. Lanzar Excepciones**

---

#### **Uso de `throw` y `throws`**
- **`throw`**: Se utiliza para lanzar una excepción explícitamente.

  ```java
  throw new IOException("Error de entrada/salida");
  ```

- **`throws`**: Se utiliza en la declaración de un método para indicar que puede lanzar una excepción que el llamador debe manejar.

  ```java
  public void miMetodo() throws IOException {
      // Código que puede lanzar IOException
  }
  ```

---

### **7. Bloques `finally` y Recursos Autocerrables**

---

#### **Bloque `finally`**
El bloque `finally` siempre se ejecuta, incluso si el bloque `try` lanza una excepción o se ejecuta un `return`.

```java
try {
    int resultado = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("División por cero");
} finally {
    System.out.println("Este bloque siempre se ejecuta");
}
```

#### **Manejo automático de recursos con `try-with-resources`**
El bloque `try-with-resources` es una forma de asegurarse de que los recursos como archivos o conexiones se cierren automáticamente al finalizar el bloque.

```java
try (BufferedReader br = new BufferedReader(new FileReader("archivo.txt"))) {
    // Leer archivo
} catch (IOException e) {
    e.printStackTrace();
}
```

---

### **8. Buenas Prácticas al Manejar Excepciones**

---

1. **Usar excepciones específicas**: Captura la excepción más específica posible para proporcionar un manejo más preciso.

2. **No suprimir excepciones**: Nunca dejes bloques `catch` vacíos. Siempre maneja o informa de la excepción.

   ```java
   try {
       int resultado = 10 / 0;
   } catch (ArithmeticException e) {
       System.out.println("División por cero detectada");
   }
   ```

3. **Documentar excepciones**: Usa la etiqueta `@throws` en los comentarios Javadoc para documentar qué excepciones puede lanzar un método.

4. **Proporcionar mensajes de excepción claros**: Cuando lances excepciones, proporciona mensajes informativos que faciliten el diagnóstico del error.

---

### **9. Preguntas Frecuentes y Dudas Comunes**

---

1. **¿Por qué no todas las excepciones requieren `try-catch`?**
   Las excepciones no verificadas (`RuntimeException`) no necesitan ser capturadas o declaradas en los métodos porque se consideran errores de programación que deberían ser corregidos.

2. **¿Qué hacer cuando no sabes qué tipo de excepción lanzar?**
   En casos generales, puedes lanzar excepciones estándar de Java como `IllegalArgumentException` o `IllegalStateException`, dependiendo de si el error se debe a un argumento inválido o un estado inconsistente del programa.

3. **¿Cuál es la diferencia entre `Error` y